const nextjs = {
  title: 'Next.js',
  info: '16개 섹션 • 359개의 강의 • 총 길이: 32시간 40분',
  sec3: {
    title: 'section 3: next 핵심(app router)',
    info: '48/4h 5m',
    curriculum: [
      { episode: '모듈 소개', duration: '01:20' },
      { episode: '기본 설치 소개', duration: '02:32' },
      {
        episode: '파일 기반 라우팅과 리액트 서버 컴포넌트의 이해',
        duration: '02:45',
      },
      { episode: '파일 시스템을 통한 추가 경로 추가', duration: '03:06' },
      { episode: '페이지 간 이동—옳고 그른 해결책', duration: '04:12' },
      { episode: '페이지 및 레이아웃 작업하기', duration: '03:22' },
      {
        episode: '보호된 파일명, 커스텀 컴포넌트 및 NextJS 프로젝트 정리 방법',
        duration: '06:31',
      },
      { episode: '보호된 파일명', duration: '01:00' },
      {
        episode: '동적 경로 환경설정 및 경로 매개 변수 사용 방법',
        duration: '06:17',
      },
      {
        episode: '주요 프로젝트를 향해: 미식가(Foodies) 앱',
        duration: '01:24',
      },
      { episode: '연습문제: 작업 내용', duration: '02:03' },
      { episode: '연습문제: 해답', duration: '08:19' },
      { episode: '레이아웃 개념 다시 보기', duration: '03:50' },
      { episode: '레이아웃에 커스텀 컴포넌트 추가', duration: '05:58' },
      { episode: 'NextJS 디자인: 옵션 및 CSS 모듈 사용', duration: '06:00' },
      {
        episode: 'NextJS 이미지 컴포넌트를 통한 이미지 최적화',
        duration: '04:57',
      },
      { episode: '기타 커스텀 컴포넌트 사용', duration: '03:48' },
      { episode: '시작 페이지 내용 채우기', duration: '04:18' },
      { episode: '이미지 슬라이드쇼 준비', duration: '03:25' },
      {
        episode:
          '리액트 서버 컴포넌트 vs 클라이언트 컴포넌트 – 적절한 사용 선택 방법',
        duration: '08:15',
      },
      { episode: '클라이언트 컴포넌트의 효율적 사용', duration: '11:07' },
      {
        episode: 'Meals 데이터와 규격이 불분명한 이미지 출력',
        duration: '10:31',
      },
      { episode: 'SQLite 데이터베이스 설정', duration: '03:11' },
      {
        episode: 'NextJS 및 풀스택 기능을 활용한 데이터 불러오기',
        duration: '07:17',
      },
      { episode: '로딩 페이지 추가', duration: '04:00' },
      {
        episode: 'Suspense & Streamed Response를 이용한 세분화 로딩 상태 관리',
        duration: '05:54',
      },
      { episode: '오류 처리 방법', duration: '05:22' },
      { episode: '‘Not Found’ 상태 처리 방법', duration: '01:57' },
      {
        episode:
          '동적 경로와 경로 매개변수를 활용한 Meals 세부내용 로딩 및 렌더링',
        duration: '11:03',
      },
      { episode: '개별 Meals에 대한 Not Found 오류 전송', duration: '02:03' },
      { episode: '‘Share Meal’ 양식 사용에 대한 기초', duration: '01:53' },
      {
        episode: '커스텀 이미지 피커(선택 도구) 입력 컴포넌트에 대한 기초',
        duration: '08:28',
      },
      { episode: '피커에 이미지 미리보기 추가', duration: '05:59' },
      { episode: '이미지 피커 컴포넌트 개선하기', duration: '00:38' },
      {
        episode: '양식 제출 처리를 위한 서버 액션 소개 및 사용 방법',
        duration: '09:02',
      },
      { episode: '개별 파일에 서버 액션 저장', duration: '03:45' },
      {
        episode: 'XSS 보호를 위한 슬러그 생성 및 유저 입력 무결 처리하기',
        duration: '03:20',
      },
      {
        episode: '업로드 된 이미지 저장 및 데이터베이스에 데이터 저장',
        duration: '12:56',
      },
      {
        episode: 'useFormStatus를 이용한 양식 제출 상태 관리',
        duration: '05:30',
      },
      { episode: '서버 사이드 입력 유효성 확인 추가 방법', duration: '05:54' },
      { episode: '서버 행동 응답 및 useFormState 작업', duration: '08:05' },
      { episode: 'NextJS 캐싱 구축 및 이해', duration: '06:06' },
      { episode: '캐시 유효성 재확인 트리거', duration: '03:57' },
      { episode: '로컬 Filesystem에 파일 저장 금지!', duration: '02:13' },
      {
        episode: '보너스: 업로드한 이미지를 클라우드에 저장하기(AWS S3)',
        duration: '11:00',
      },
      { episode: '정적 메타데이터 추가', duration: '03:47' },
      { episode: '동적 메타데이터 추가', duration: '02:20' },
      { episode: '모듈 요약', duration: '04:25' },
    ],
  },
  sec4: {
    title: 'section 4: page & file based routing',
    info: '19/1h 6m',
    curriculum: [
      { episode: 'App Router에서 Page Router까지', duration: '01:38' },
      { episode: '코드 스냅샷 사용하기', duration: '00:31' },
      { episode: '모듈 개요', duration: '01:12' },
      { episode: '시작 설정', duration: '01:19' },
      {
        episode: '“파일 기반 라우팅”이란 무엇인가? 이게 왜 유용한 걸까?',
        duration: '05:22',
      },
      { episode: '첫 번째 페이지 추가하기', duration: '04:01' },
      { episode: '이름이 붙은 / 정적 라우트 파일 추가하기', duration: '01:34' },
      { episode: '중첩 경로 & 라우트로 작업하기', duration: '03:33' },
      { episode: '동적 경로 & 라우트 추가하기', duration: '04:54' },
      {
        episode: '동적 경로 세그먼트 데이터 추출하기 (동적 라우트)',
        duration: '04:54',
      },
      { episode: '중첩된 동적 라우트 & 경로 구축하기', duration: '07:12' },
      { episode: 'Catch-All 라우트 추가하기', duration: '05:44' },
      { episode: '“Link” 컴포넌트로 내비게이팅하기', duration: '05:44' },
      { episode: '동적 라우트로 내비게이팅하기', duration: '03:41' },
      { episode: 'Link Href를 설정하는 다른 방법', duration: '02:55' },
      { episode: '프로그래밍 방식으로 내비게이팅하기', duration: '03:50' },
      { episode: '커스텀 404 페이지 추가하기', duration: '01:35' },
      { episode: '모듈 요약', duration: '05:51' },
      { episode: '모듈 리소스', duration: '00:33' },
    ],
  },
};

const typescript = {
  title: 'Typescript',
  info: '19개 섹션',
  sec5: {
    title: '섹션 5. 인터페이스',
    info: '6 강 ∙ 20분',
    curriculum: [
      {
        episode: '인터페이스 소개 및 변수를 정의하는 인터페이스',
        duration: '02:25',
      },
      { episode: '함수의 인자를 정의하는 인터페이스', duration: '04:05' },
      {
        episode: '함수 구조를 정의하는 인터페이스',
        duration: '03:19',
      },
      {
        episode: '인덱싱 방식을 정의하는 인터페이스',
        duration: '02:50',
      },
      { episode: '인터페이스 딕셔너리 패턴', duration: '05:09' },
      { episode: '인터페이스 확장(상속)', duration: '03:11' },
    ],
  },
  sec6: {
    title: '섹션 6. 타입 별칭',
    info: '3 강 ∙ 9분',
    curriculum: [
      { episode: '타입 별칭 소개', duration: '01:54' },
      { episode: '타입 별칭 코드 예제', duration: '03:47' },
      {
        episode: '타입 별칭과 인터페이스의 차이점',
        duration: '03:49',
      },
    ],
  },
  sec7: {
    title: '섹션 7. 연산자를 이용한 타입 정의',
    info: '5 강 ∙ 17분',
    curriculum: [
      {
        episode: '연산자를 이용한 타입 정의 - Union Type',
        duration: '03:05',
      },
      { episode: '유니온 타입의 장점', duration: '03:16' },
      { episode: '유니온 타입의 특징', duration: '03:29' },
      { episode: '인터섹션 타입 소개', duration: '03:32' },
      { episode: '유니온 타입과 인터섹션 타입의 차이점', duration: '04:17' },
    ],
  },
  sec8: {
    title: '섹션 8. 이넘',
    info: '4 강 ∙ 10분',
    curriculum: [
      { episode: '이넘 소개', duration: '00:56' },
      { episode: '숫자형 이넘', duration: '02:09' },
      { episode: '문자형 이넘', duration: '02:34' },
      { episode: '이넘 활용 사례', duration: '04:44' },
    ],
  },
  sec9: {
    title: '섹션 9. 클래스',
    info: '5 강 ∙ 21분',
    curriculum: [
      { episode: '클래스 소개', duration: '04:25' },
      {
        episode: '자바스크립트 프로토타입 소개',
        duration: '06:02',
      },
      {
        episode: '자바스크립트 프로토타입의 활용 사례',
        duration: '03:14',
      },
      {
        episode: '프로토타입과 클래스와의 관계',
        duration: '02:30',
      },
      {
        episode: '타입스크립트의 클래스 문법',
        duration: '05:11',
      },
    ],
  },
  sec10: {
    title: '섹션 10. 제네릭',
    info: '12 강 ∙ 56분',
    curriculum: [
      { episode: '제네릭 소개', duration: '01:57' },
      { episode: '제네릭의 기본 문법', duration: '05:30' },
      {
        episode:
          '기존 타입 정의 방식과 제네릭의 차이점 - 함수 중복 선언의 단점',
        duration: '04:17',
      },
      {
        episode:
          '기존 문법과 제네릭의 차이점 - 유니온 타입을 이용한 선언 방식의 문제점',
        duration: '03:33',
      },
      {
        episode: '제네릭의 장점과 타입 추론에서의 이점',
        duration: '04:02',
      },
      {
        episode: '제네릭 실전 예제 살펴보기 - 예제 설명',
        duration: '04:50',
      },
      {
        episode:
          '제네릭 실전 예제 살펴보기 - 코드에 타입 정의하기',
        duration: '08:26',
      },
      {
        episode: '인터페이스에 제네릭을 선언하는 방법',
        duration: '03:31',
      },
      {
        episode:
          '제네릭 실전 예제 살펴보기 - 제네릭을 이용한 타입 정의',
        duration: '04:53',
      },
      { episode: '제네릭의 타입 제한', duration: '05:38' },
      {
        episode: '정의된 타입으로 타입을 제한하기',
        duration: '04:46',
      },
      {
        episode: 'keyof로 제네릭의 타입 제한하기',
        duration: '05:05',
      },
    ],
  },
  sec11: {
    title: '섹션 11. 두 번째 프로젝트: 전화번호부 앱',
    info: '7 강',
    curriculum: [
      { episode: '11.1 프로젝트 환경 구성' },
      { episode: '11.2 프로젝트 폴더 구조' },
      { episode: '11.2.1 node_modules 폴더' },
      { episode: '11.2.2 src 폴더' },
      { episode: '11.2.3 .eslintrc.js' },
      { episode: '11.2.4 package.json, package-lock.json 파일' },
      { episode: '11.2.5 tsconfig.json 파일' },
      { episode: '11.3 프로젝트 로직' },
      { episode: '11.3.1 인터페이스 코드' },
      { episode: '11.3.2 api 함수' },
      { episode: '11.3.3 전화번호부 클래스' },
      { episode: '11.4 프로젝트 실습' },
      {
        episode: '11.4.1 타입스크립트 설정 파일의 noImplicitAny 속성 값 변경',
      },
      { episode: '11.4.2 타입스크립트 설정 파일의 strict 속성 값 변경' },
      { episode: '11.5 프로젝트 실습 풀이: 첫 번째' },
      { episode: '11.5.1 클래스 속성 타입 정의' },
      { episode: '11.5.2 함수 파라미터 타입 정의' },
      { episode: '11.5.3 API 함수 반환 타입 정의' },
      { episode: '11.6 프로젝트 실습 풀이: 두 번째' },
      { episode: '11.6.1 함수 반환 타입 정의' },
      { episode: '__11.6.2 함수 파라미터에 이넘 타입 적용' },
      { episode: '11.7 정리' },
    ],
  },
  sec12: {
    title: '섹션 12. 타입 추론',
    info: '',
    curriculum: [
      { duration: '12.1 타입 추론이란?' },
      { duration: '12.2 변수의 타입 추론 과정' },
      { duration: '12.3 함수의 타입 추론: 반환 타입' },
      { duration: '12.4 함수의 타입 추론: 파라미터 타입' },
      { duration: '12.5 인터페이스와 제네릭의 추론 방식' },
      { duration: '12.6 복잡한 구조에서 타입 추론 방식' },
      { duration: '12.7 정리' },
    ],
  },
  sec13: {
    title: '섹션 13. 타입 단언',
    info: '',
    curriculum: [
      { episode: '13.1 타입 단언이란?' },
      { episode: '13.2 타입 단언 문법' },
      { episode: '13.2.1 타입 단언의 대상' },
      { episode: '13.2.2 타입 단언 중첩' },
      { episode: '__13.2.3 타입 단언을 사용할 때 주의할 점' },
      { episode: '13.3 null 아님 보장 연산자: !' },
      { episode: '13.4 정리}' },
    ],
  },
  sec14: {
    title: '섹션 14. 타입 가드',
    info: '',
    curriculum: [
      { episode: '14.1 타입 가드란?' },
      { episode: '14.2 왜 타입 가드가 필요할까?' },
      { episode: '14.2.1 타입 단언으로 타입 에러 해결하기' },
      { episode: '14.2.2 타입 단언으로 해결했을 때 문제점' },
      { episode: '14.2.3 타입 가드로 문제점 해결하기' },
      { episode: '14.3 타입 가드 문법' },
      { episode: '14.3.1 typeof 연산자' },
      { episode: '14.3.2 instanceof 연산자' },
      { episode: '14.3.3 in 연산자' },
      { episode: '14.4 타입 가드 함수' },
      { episode: '14.4.1 타입 가드 함수 예시' },
      { episode: '14.4.2 복잡한 경우의 타입 가드 예시' },
      { episode: '14.5 구별된 유니언 타입' },
      { episode: '14.6 switch 문과 연산자' },
      { episode: '14.6.1 switch 문' },
      { episode: '14.6.2 논리?비교 연산자' },
      { episode: '14.7 정리' },
    ],
  },
  sec15: {
    title: '섹션 15. 타입 호환',
    info: '',
    curriculum: [
      { episode: '15.1 타입 호환이란?' },
      { episode: '15.2 다른 언어와 차이점' },
      { episode: '15.2.1 구조적 타이핑' },
      { episode: '15.3 객체 타입의 호환' },
      { episode: '15.4 함수 타입의 호환' },
      { episode: '15.5 이넘 타입의 호환' },
      { episode: '15.5.1 숫자형 이넘과 호환되는 number 타입' },
      { episode: '__15.5.2 이넘 타입 간 호환 여부' },
      { episode: '15.6 제네릭 타입의 호환' },
      { episode: '15.7 정리' },
    ],
  },
  sec16: {
    title: '섹션 16. 타입 모듈',
    info: '',
    curriculum: [
      { episode: '16.1 모듈이란?' },
      { episode: '16.2 자바스크립트 모듈' },
      { episode: '16.2.1 자바스크립트의 태생적 한계' },
      { episode: '16.2.2 자바스크립트 모듈화를 위한 시도들' },
      { episode: '16.3 자바스크립트 모듈화 문법' },
      { episode: '16.3.1 import와 export' },
      { episode: '16.3.2 export default 문법' },
      { episode: '16.3.3 import as 문법' },
      { episode: '16.3.4 import * 문법' },
      { episode: '16.3.5 export 위치' },
      { episode: '16.4 타입스크립트 모듈' },
      { episode: '16.5 타입스크립트 모듈 유효 범위' },
      { episode: '16.6 타입스크립트 모듈화 문법' },
      { episode: '16.6.1 import type 문법' },
      { episode: '16.6.2 import inline type 문법' },
      { episode: '16.6.3 import와 import type 중 어떤 문법을 써야 할까?' },
      { episode: '16.7 모듈화 전략: Barrel' },
      { episode: '16.8 정리' },
    ],
  },
  sec17: {
    title: '섹션 17. 유틸리티 타입',
    info: '',
    curriculum: [
      { episode: '17.1 유틸리티 타입이란?' },
      { episode: '17.2 Pick 유틸리티 타입' },
      { episode: '17.2.1 Pick 타입 예시' },
      { episode: '17.2.2 Pick 타입 문법' },
      { episode: '17.3 Omit 유틸리티 타입' },
      { episode: '17.3.1 Omit 타입 문법' },
      { episode: '17.3.2 Omit 타입 예시' },
      { episode: '17.3.3 Omit 타입과 Pick 타입 비교' },
      { episode: '17.4 Partial 유틸리티 타입' },
      { episode: '17.4.1 Partial 타입 문법' },
      { episode: '17.4.2 Partial 타입 예시' },
      { episode: '17.5 Exclude 유틸리티 타입' },
      { episode: '17.5.1 Exclude 타입 문법' },
      { episode: '17.5.2 Exclude 타입 예시' },
      { episode: '17.6 Record 유틸리티 타입' },
      { episode: '17.6.1 Record 타입 첫 번째 예시' },
      { episode: '17.6.2 Record 타입 두 번째 예시' },
      { episode: '17.6.3 Record 타입 문법' },
      { episode: '17.7 그 외의 유틸리티 타입' },
      { episode: '17.8 정리' },
    ],
  },
  sec18: {
    title: '섹션 18. 맵드 타입',
    info: '',
    curriculum: [
      { episode: '18.1 맵드 타입 첫 번째 예시: in' },
      { episode: '18.2 map( ) API로 이해하는 맵드 타입' },
      { episode: '18.3 맵드 타입 두 번째 예시: keyof' },
      { episode: '18.4 맵드 타입을 사용할 때 주의할 점' },
      { episode: '18.5 매핑 수정자' },
      { episode: '18.6 맵드 타입으로 직접 유틸리티 타입 만들기' },
      { episode: '18.7 정리' },
    ],
  },
  sec19: {
    title: '섹션 19. 실전 프로젝트 환경 구성',
    info: '',
    curriculum: [
      { episode: '19.1 타입스크립트 설정 파일' },
      { episode: '19.2 타입스크립트 설정 파일 생성' },
      { episode: '19.3 타입스크립트 설정 파일의 루트 옵션' },
      { episode: '19.3.1 files' },
      { episode: '19.3.2 include' },
      { episode: '19.3.3 exclude' },
      { episode: '19.3.4 extends' },
      { episode: '19.4 타입스크립트 설정 파일의 컴파일러 옵션' },
      { episode: '19.4.1 target' },
      { episode: '19.4.2 lib' },
      { episode: '19.4.3 strict' },
      { episode: '19.4.4 noImplicitAny' },
      { episode: '19.4.5 strictNullChecks' },
      { episode: '19.4.6 allowJs' },
      { episode: '19.4.7 sourceMap' },
      { episode: '19.4.8 jsx' },
      { episode: '19.4.9 baseUrl' },
      { episode: '19.4.10 paths' },
      { episode: '19.4.11 removeComments' },
      { episode: '19.5 타입스크립트 설정 파일과 빌드 도구' },
      { episode: '19.5.1 웹팩이란?' },
      { episode: '19.5.2 웹팩에 타입스크립트 설정하기' },
      { episode: '19.6 타입 선언 파일' },
      { episode: '19.6.1 타입 선언 파일 사용 방법' },
      { episode: '19.6.2 타입 선언 파일을 언제 사용해야 하는가?' },
      { episode: '19.7 외부 라이브러리의 타입 선언과 활용' },
      { episode: '19.7.1 외부 라이브러리를 사용하는 방법' },
      { episode: '19.7.2 외부 라이브러리의 타입 선언 파일: Definitely Typed' },
      { episode: '19.7.3 외부 라이브러리에 내장된 타입 선언 파일' },
      {
        episode: '19.7.4 외부 라이브러리에 타입 선언 파일이 지원되지 않는 경우',
      },
      { episode: '19.8 정리' },
    ],
  },
};
